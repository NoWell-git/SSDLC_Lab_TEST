package main

import (
	"bufio"
	"context"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"unicode/utf8"

	"github.com/jackc/pgx/v5"
	"github.com/joho/godotenv"
)

type Table struct {
	ID   int
	Name string
}

var tables = []Table{
	{1, "categories"},
	{2, "manufacturers"},
	{3, "components"},
	{4, "stock"},
}

var columns = map[string][]string{
	"categories":     {"id", "name", "description"},
	"manufacturers":  {"id", "name", "country", "founded_year"},
	"components":     {"id", "name", "category_id", "manufacturer_id", "model", "price", "specs"},
	"stock":          {"id", "component_id", "quantity", "warehouse_location", "last_updated"},
}

type Config struct {
	Host     string
	Port     string
	Database string
	User     string
	Password string
	SSLMode  string
	LogFile  string
}

type App struct {
	conn   *pgx.Conn
	logger *log.Logger
	file   *os.File
}

func loadConfig() (Config, error) {
	godotenv.Load("config.env")
	return Config{
		Host:     os.Getenv("DB_HOST"),
		Port:     os.Getenv("DB_PORT"),
		Database: os.Getenv("DB_NAME"),
		User:     os.Getenv("DB_USER"),
		Password: os.Getenv("DB_PASSWORD"),
		SSLMode:  os.Getenv("DB_SSLMODE"),
		LogFile:  os.Getenv("LOG_FILE"),
	}, nil
}

func main() {
	cfg, _ := loadConfig()

	fmt.Print("Логин: ")
	userInput := readLine()
	if userInput == "" {
		fmt.Println("Логин не может быть пустым")
		os.Exit(1)
	}
	fmt.Print("Пароль: ")
	passInput := readLine()
	if passInput == "" {
		fmt.Println("Пароль не может быть пустым")
		os.Exit(1)
	}
	cfg.User, cfg.Password = userInput, passInput

	var logWriter *os.File
	if cfg.LogFile != "" {
		var err error
		logWriter, err = os.OpenFile(cfg.LogFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Ошибка лога: %v\n", err)
			os.Exit(1)
		}
		defer logWriter.Close()
	}

	logger := log.New(os.Stdout, "", log.LstdFlags)
	if logWriter != nil {
		logger = log.New(logWriter, "", log.LstdFlags)
	}

	connStr := fmt.Sprintf("host=%s port=%s database=%s user=%s password=%s sslmode=%s",
		cfg.Host, cfg.Port, cfg.Database, cfg.User, cfg.Password, cfg.SSLMode)

	ctx := context.Background()
	conn, err := pgx.Connect(ctx, connStr)
	if err != nil {
		logger.Printf("Ошибка подключения: %v", err)
		fmt.Fprintln(os.Stderr, "Не удалось подключиться к БД.")
		os.Exit(1)
	}
	defer conn.Close(ctx)

	logger.Println("Подключение к БД успешно")
	fmt.Println("Подключение к БД успешно!")

	app := &App{conn: conn, logger: logger, file: logWriter}
	app.run()
}

// === ГЛАВНОЕ МЕНЮ ===
func (a *App) run() {
	scanner := bufio.NewScanner(os.Stdin)
	for {
		printMenu()
		fmt.Print("> ")
		if !scanner.Scan() {
			break
		}
		choice := strings.TrimSpace(scanner.Text())
		if choice == "" {
			fmt.Println("Выбор не может быть пустым")
			continue
		}
		switch choice {
		case "1":
			a.viewTable()
		case "2":
			a.filterTable()
		case "3":
			a.updateRecords()
		case "4":
			a.insertIntoTable()
		case "5":
			a.insertRelated()
		case "0", "exit", "quit":
			fmt.Println("Выход...")
			return
		default:
			fmt.Println("Неверный выбор")
		}
	}
}

func printMenu() {
	fmt.Println("\n=== МЕНЮ ===")
	fmt.Println("1. Просмотр таблицы (без фильтра)")
	fmt.Println("2. Фильтрация (по одному полю или нескольким полям)")
	fmt.Println("3. Обновить запись (одну или несколько)")
	fmt.Println("4. Добавить запись в таблицу (одну или несколько)")
	fmt.Println("5. Добавить запись в связанные таблицы (одну или несколько)")
	fmt.Println("0. Выход")
}

// === ВЫБОР С 0 (ВЫХОД В ГЛАВНОЕ МЕНЮ) ===
func (a *App) selectWithBack(prompt string, options []string, optionNames []string) string {
	for {
		fmt.Println(prompt)
		for i, name := range optionNames {
			fmt.Printf("%d. %s\n", i+1, name)
		}
		fmt.Println("0. Назад")
		fmt.Print("> ")
		choice := readLine()
		if choice == "" {
			fmt.Println("Выбор не может быть пустым")
			continue
		}
		if choice == "0" {
			return ""
		}
		idx, err := strconv.Atoi(choice)
		if err != nil || idx < 1 || idx > len(options) {
			fmt.Println("Неверный выбор")
			continue
		}
		return options[idx-1]
	}
}

// === ВЫБОР РЕЖИМА (1, 2, 0) ===
func (a *App) selectMode(prompt1, prompt2 string) string {
	for {
		fmt.Println("1. " + prompt1)
		fmt.Println("2. " + prompt2)
		fmt.Println("0. Назад")
		fmt.Print("> ")
		choice := readLine()
		if choice == "" {
			fmt.Println("Выбор не может быть пустым")
			continue
		}
		if choice == "0" {
			return ""
		}
		if choice == "1" || choice == "2" {
			return choice
		}
		fmt.Println("Введите 1, 2 или 0")
	}
}

// === ВЫБОР ТАБЛИЦЫ ===
func (a *App) selectTable(prompt string) string {
	tableNames := make([]string, len(tables))
	for i, t := range tables {
		tableNames[i] = t.Name
	}
	return a.selectWithBack(prompt, tableNames, tableNames)
}

// === ВЫБОР КОЛОНКИ (ВКЛЮЧАЯ ID) ===
func (a *App) selectColumn(table string) string {
	cols := columns[table]
	valid := map[int]string{}
	counter := 1
	fmt.Println("Выберите колонку:")
	for _, c := range cols {
		valid[counter] = c
		fmt.Printf("%d. %s\n", counter, c)
		counter++
	}
	fmt.Println("0. Назад")
	for {
		fmt.Print("> ")
		choice := readLine()
		if choice == "" {
			fmt.Println("Выбор не может быть пустым")
			continue
		}
		if choice == "0" {
			return ""
		}
		idx, err := strconv.Atoi(choice)
		if err != nil {
			fmt.Println("Введите корректный номер")
			continue
		}
		if col, ok := valid[idx]; ok {
			return col
		}
		fmt.Println("Неверный номер колонки")
	}
}

func (a *App) selectMultipleColumns(table string) []string {
	cols := columns[table]
	valid := map[int]string{}
	counter := 1
	fmt.Println("Выберите колонки (через запятую):")
	for _, c := range cols {
		if c != "id" {
			valid[counter] = c
			fmt.Printf("%d. %s\n", counter, c)
			counter++
		}
	}
	fmt.Println("0. Назад")
	for {
		fmt.Print("> ")
		choice := readLine()
		if choice == "" {
			fmt.Println("Выбор не может быть пустым")
			continue
		}
		if choice == "0" {
			return nil
		}
		choices := strings.Split(choice, ",")
		selected := []string{}
		validChoice := true
		for _, ch := range choices {
			ch = strings.TrimSpace(ch)
			if ch == "" {
				continue
			}
			idx, err := strconv.Atoi(ch)
			if err != nil || valid[idx] == "" {
				validChoice = false
				break
			}
			col := valid[idx]
			duplicate := false
			for _, s := range selected {
				if s == col {
					duplicate = true
					break
				}
			}
			if !duplicate {
				selected = append(selected, col)
			}
		}
		if !validChoice {
			fmt.Println("Некорректный ввод. Попробуйте снова.")
			continue
		}
		if len(selected) == 0 {
			fmt.Println("Выберите хотя бы одну колонку")
			continue
		}
		return selected
	}
}

// === 1. ПРОСМОТР ===
func (a *App) viewTable() {
	table := a.selectTable("Выберите таблицу для просмотра:")
	if table == "" {
		return
	}
	rows, err := a.conn.Query(context.Background(), fmt.Sprintf("SELECT * FROM %s", table))
	if err != nil {
		a.logError("не удалось прочитать таблицу")
		return
	}
	defer rows.Close()
	printRowsAligned(rows)
	a.logger.Printf("Просмотр: %s", table)
}

// === 2. ФИЛЬТРАЦИЯ (ПО ID ВКЛЮЧЕНО) ===
func (a *App) filterTable() {
	mode := a.selectMode("Фильтр по одному полю", "Фильтр по нескольким полям")
	if mode == "" {
		return
	}
	table := a.selectTable("Выберите таблицу для фильтрации:")
	if table == "" {
		return
	}

	var where []string
	var args []interface{}

	if mode == "1" {
		col := a.selectColumn(table)
		if col == "" {
			return
		}
		fmt.Printf("Значение для %s: ", col)
		val := readLine()
		if val == "" {
			fmt.Println("Значение не может быть пустым")
			return
		}
		where = append(where, fmt.Sprintf("%s = $%d", col, len(args)+1))
		args = append(args, val)
	} else {
		for {
			col := a.selectColumn(table)
			if col == "" {
				break
			}
			fmt.Printf("Значение для %s: ", col)
			val := readLine()
			if val == "" {
				fmt.Println("Значение не может быть пустым")
				break
			}
			where = append(where, fmt.Sprintf("%s = $%d", col, len(args)+1))
			args = append(args, val)
			fmt.Print("Добавить ещё? (y/n): ")
			if strings.ToLower(readLine()) != "y" {
				break
			}
		}
	}

	if len(where) == 0 {
		fmt.Println("Фильтры не указаны")
		return
	}

	query := fmt.Sprintf("SELECT * FROM %s WHERE %s", table, strings.Join(where, " AND "))
	rows, err := a.conn.Query(context.Background(), query, args...)
	if err != nil {
		a.logError("ошибка фильтрации")
		return
	}
	defer rows.Close()
	printRowsAligned(rows)
	a.logger.Printf("Фильтрация: %s", query)
}

// === 3. ОБНОВЛЕНИЕ (ИСПРАВЛЕНО: ID → КОЛОНКА → ЗНАЧЕНИЕ) ===
func (a *App) updateRecords() {
	mode := a.selectMode("Обновить одну запись", "Обновить несколько записей")
	if mode == "" {
		return
	}
	table := a.selectTable("Выберите таблицу для обновления:")
	if table == "" {
		return
	}

	if mode == "1" {
		fmt.Print("ID записи: ")
		id := readLine()
		if id == "" {
			fmt.Println("ID не может быть пустым")
			return
		}
		_, err := strconv.Atoi(id)
		if err != nil {
			fmt.Println("ID должен быть числом")
			return
		}
		updates, args := a.collectUpdates(table)
		if len(updates) == 0 {
			return
		}
		args = append(args, id)
		query := fmt.Sprintf("UPDATE %s SET %s WHERE id = $%d", table, strings.Join(updates, ", "), len(args))
		_, err = a.conn.Exec(context.Background(), query, args...)
		if err != nil {
			a.logError("не удалось обновить запись")
			return
		}
		fmt.Println("Запись обновлена")
		a.logger.Printf("Обновление: %s", query)
	} else {
		// Сначала ID
		fmt.Print("ID записей (через запятую): ")
		idsStr := readLine()
		if idsStr == "" {
			fmt.Println("ID не могут быть пустыми")
			return
		}
		ids := strings.Split(idsStr, ",")
		validIDs := []string{}
		args := []interface{}{}
		for _, v := range ids {
			v = strings.TrimSpace(v)
			if v == "" {
				continue
			}
			_, err := strconv.Atoi(v)
			if err != nil {
				fmt.Println("Все ID должны быть числами")
				return
			}
			validIDs = append(validIDs, v)
		}
		if len(validIDs) == 0 {
			fmt.Println("Укажите хотя бы один ID")
			return
		}

		// Потом колонка
		col := a.selectColumn(table)
		if col == "" {
			return
		}

		// Потом значение
		fmt.Print("Новое значение: ")
		newVal := readLine()
		if newVal == "" {
			fmt.Println("Значение не может быть пустым")
			return
		}
		args = append(args, newVal)

		// Формируем IN
		inArgs := make([]string, len(validIDs))
		for i, id := range validIDs {
			inArgs[i] = "$" + strconv.Itoa(i+2)
			args = append(args, id)
		}

		query := fmt.Sprintf("UPDATE %s SET %s = $1 WHERE id IN (%s)", table, col, strings.Join(inArgs, ","))
		_, err := a.conn.Exec(context.Background(), query, args...)
		if err != nil {
			a.logError("ошибка массового обновления")
			return
		}
		fmt.Println("Записи обновлены")
		a.logger.Printf("Массовое обновление: %s", query)
	}
}

// === 4. ДОБАВИТЬ В ТАБЛИЦУ ===
func (a *App) insertIntoTable() {
	mode := a.selectMode("Добавить одну запись", "Добавить несколько записей")
	if mode == "" {
		return
	}
	table := a.selectTable("Выберите таблицу для вставки:")
	if table == "" {
		return
	}

	if mode == "1" {
		a.insertSingle(table)
	} else {
		a.insertMultiple(table)
	}
}

func (a *App) insertSingle(table string) {
	cols := a.selectMultipleColumns(table)
	if cols == nil {
		return
	}
	values := make([]string, len(cols))
	args := make([]interface{}, len(cols))
	for i, col := range cols {
		fmt.Printf("%s: ", col)
		val := readLine()
		if val == "" {
			fmt.Printf("Значение для %s не может быть пустым\n", col)
			return
		}
		values[i] = "$" + strconv.Itoa(i+1)
		args[i] = val
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)", table, strings.Join(cols, ", "), strings.Join(values, ", "))
	_, err := a.conn.Exec(context.Background(), query, args...)
	if err != nil {
		a.logError("не удалось добавить запись")
		return
	}
	fmt.Println("Запись добавлена")
	a.logger.Printf("Вставка: %s", query)
}

func (a *App) insertMultiple(table string) {
	cols := a.selectMultipleColumns(table)
	if cols == nil {
		return
	}
	fmt.Print("Сколько записей? ")
	nStr := readLine()
	if nStr == "" {
		fmt.Println("Количество не может быть пустым")
		return
	}
	n, err := strconv.Atoi(nStr)
	if err != nil || n <= 0 {
		fmt.Println("Введите корректное положительное число")
		return
	}
	args := []interface{}{}
	placeholders := []string{}
	for i := 0; i < n; i++ {
		row := []string{}
		for j := range cols {
			fmt.Printf("[%d] %s: ", i+1, cols[j])
			val := readLine()
			if val == "" {
				fmt.Printf("Значение для %s не может быть пустым\n", cols[j])
				return
			}
			placeholder := "$" + strconv.Itoa(len(args)+1)
			row = append(row, placeholder)
			args = append(args, val)
		}
		placeholders = append(placeholders, "("+strings.Join(row, ", ")+")")
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s", table, strings.Join(cols, ", "), strings.Join(placeholders, ", "))
	_, err = a.conn.Exec(context.Background(), query, args...)
	if err != nil {
		a.logError("ошибка множественной вставки")
		return
	}
	fmt.Println("Записи добавлены")
	a.logger.Printf("Множественная вставка: %d в %s", n, table)
}

// === 5. СВЯЗАННЫЕ ТАБЛИЦЫ ===
func (a *App) insertRelated() {
	mode := a.selectMode("Добавить одну пару (component + stock)", "Добавить несколько пар")
	if mode == "" {
		return
	}
	if mode == "1" {
		a.insertRelatedSingle()
	} else {
		a.insertRelatedMultiple()
	}
}

func (a *App) insertRelatedSingle() {
	var compID int
	price := 99.99
	err := a.conn.QueryRow(context.Background(),
		`INSERT INTO components (name, category_id, manufacturer_id, model, price, specs)
		 VALUES ($1, $2, $3, $4, $5, $6) RETURNING id`,
		"New CPU", 1, 1, "X-100", price, `{"test": true}`,
	).Scan(&compID)
	if err != nil {
		a.logError("ошибка вставки в components")
		return
	}
	_, err = a.conn.Exec(context.Background(),
		`INSERT INTO stock (component_id, quantity, warehouse_location) VALUES ($1, $2, $3)`,
		compID, 10, "WH-X1")
	if err != nil {
		a.logError("ошибка вставки в stock")
		return
	}
	fmt.Println("Пара добавлена")
	a.logger.Printf("Связанная вставка: component_id=%d", compID)
}

func (a *App) insertRelatedMultiple() {
	fmt.Print("Сколько пар? ")
	nStr := readLine()
	if nStr == "" {
		fmt.Println("Количество не может быть пустым")
		return
	}
	n, err := strconv.Atoi(nStr)
	if err != nil || n <= 0 {
		fmt.Println("Введите корректное число")
		return
	}
	for i := 0; i < n; i++ {
		fmt.Printf("\n--- Пара %d ---\n", i+1)
		var compID int
		price := 99.99 + float64(i)*10.0
		err := a.conn.QueryRow(context.Background(),
			`INSERT INTO components (name, category_id, manufacturer_id, model, price, specs)
			 VALUES ($1, $2, $3, $4, $5, $6) RETURNING id`,
			fmt.Sprintf("CPU-%d", i+1), 1, 1, fmt.Sprintf("M-%d", i+1), price, `{"test": true}`,
		).Scan(&compID)
		if err != nil {
			a.logError("ошибка вставки в components")
			continue
		}
		_, err = a.conn.Exec(context.Background(),
			`INSERT INTO stock (component_id, quantity, warehouse_location) VALUES ($1, $2, $3)`,
			compID, 5+i*2, fmt.Sprintf("WH-%d", i+1))
		if err != nil {
			a.logError("ошибка вставки в stock")
			continue
		}
		fmt.Printf("Пара %d добавлена (component_id=%d)\n", i+1, compID)
	}
	a.logger.Printf("Множественная связанная вставка: %d пар", n)
}

// === ОБНОВЛЕНИЕ ПОЛЕЙ ===
func (a *App) collectUpdates(table string) ([]string, []interface{}) {
	updates := []string{}
	args := []interface{}{}
	for {
		col := a.selectColumn(table)
		if col == "" {
			break
		}
		fmt.Printf("Новое значение для %s: ", col)
		val := readLine()
		if val == "" {
			fmt.Println("Значение не может быть пустым")
			continue
		}
		updates = append(updates, fmt.Sprintf("%s = $%d", col, len(args)+1))
		args = append(args, val)
		fmt.Print("Ещё поле? (y/n): ")
		if strings.ToLower(readLine()) != "y" {
			break
		}
	}
	return updates, args
}

// === ВЫВОД С ВЫРАВНИВАНИЕМ ===
func printRowsAligned(rows pgx.Rows) {
	fieldDescs := rows.FieldDescriptions()
	headers := make([]string, len(fieldDescs))
	colWidths := make([]int, len(fieldDescs))
	for i, fd := range fieldDescs {
		name := string(fd.Name)
		headers[i] = name
		if w := utf8.RuneCountInString(name); w > colWidths[i] {
			colWidths[i] = w
		}
	}

	values := make([]interface{}, len(fieldDescs))
	valuePtrs := make([]interface{}, len(fieldDescs))
	for i := range values {
		valuePtrs[i] = &values[i]
	}

	dataRows := [][]string{}
	for rows.Next() {
		if err := rows.Scan(valuePtrs...); err != nil {
			fmt.Println("Ошибка чтения строки")
			return
		}
		row := make([]string, len(values))
		for i, v := range values {
			s := "NULL"
			if v != nil {
				s = fmt.Sprint(v)
			}
			row[i] = s
			if w := utf8.RuneCountInString(s); w > colWidths[i] {
				colWidths[i] = w
			}
		}
		dataRows = append(dataRows, row)
	}

	parts := make([]string, len(headers))
	for i, h := range headers {
		parts[i] = padRight(h, colWidths[i])
	}
	fmt.Printf("| %s |\n", strings.Join(parts, " | "))
	fmt.Println(strings.Repeat("=", sum(colWidths)+3*len(colWidths)+1))

	for _, row := range dataRows {
		for i, cell := range row {
			parts[i] = padRight(cell, colWidths[i])
		}
		fmt.Printf("| %s |\n", strings.Join(parts, " | "))
	}
}

func padRight(s string, width int) string {
	if len := utf8.RuneCountInString(s); len < width {
		return s + strings.Repeat(" ", width-len)
	}
	return s
}

func sum(arr []int) int {
	s := 0
	for _, v := range arr {
		s += v
	}
	return s
}

func (a *App) logError(msg string) {
	a.logger.Println("ОШИБКА: " + msg)
	fmt.Fprintln(os.Stderr, "Ошибка. Подробности в логе.")
}

func readLine() string {
	scanner := bufio.NewScanner(os.Stdin)
	if scanner.Scan() {
		return strings.TrimSpace(scanner.Text())
	}
	return ""
}
